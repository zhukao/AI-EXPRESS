

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; AI Express用户手册 2.4.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AI Express用户手册
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/quick_start.html">快速上手</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/solution.html">场景参考解决方案</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xstream_guide.html">XStream用户手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xstream_tutorials.html">XStream开发指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xstream_more.html">XStream高级特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xstream_ai.html">XStream模型与策略开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/xproto.html">XProto用户手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/tools.html">工具集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/version.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../BuildAll/doc/copyright.html">版权声明</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AI Express用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/common/pybind11/docs/advanced/functions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h1>
<p>Before proceeding with this section, make sure that you are already familiar
with the basics of binding functions and classes, as explained in <span class="xref std std-doc">/basics</span>
and <span class="xref std std-doc">/classes</span>. The following guide is applicable to both free and member
functions, i.e. <em>methods</em> in Python.</p>
<div class="section" id="return-value-policies">
<span id="id1"></span><h2>Return value policies<a class="headerlink" href="#return-value-policies" title="永久链接至标题">¶</a></h2>
<p>Python and C++ use fundamentally different ways of managing the memory and
lifetime of objects managed by them. This can lead to issues when creating
bindings for functions that return a non-trivial type. Just by looking at the
type information, it is not clear whether Python should take charge of the
returned value and eventually free its resources, or if this is handled on the
C++ side. For this reason, pybind11 provides a several <em>return value policy</em>
annotations that can be passed to the <code class="xref py py-func docutils literal notranslate"><span class="pre">module::def()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">class_::def()</span></code> functions. The default policy is
<a href="#id2"><span class="problematic" id="id3">:enum:`return_value_policy::automatic`</span></a>.</p>
<p>Return value policies are tricky, and it’s very important to get them right.
Just to illustrate what can go wrong, consider the following simple example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Function declaration */</span>
<span class="n">Data</span> <span class="o">*</span><span class="nf">get_data</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_data</span><span class="p">;</span> <span class="cm">/* (pointer to a static data structure) */</span> <span class="p">}</span>
<span class="p">...</span>

<span class="cm">/* Binding code */</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_data&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">get_data</span><span class="p">);</span> <span class="c1">// &lt;-- KABOOM, will cause crash when called from Python</span>
</pre></div>
</div>
<p>What’s going on here? When <code class="docutils literal notranslate"><span class="pre">get_data()</span></code> is called from Python, the return
value (a native C++ type) must be wrapped to turn it into a usable Python type.
In this case, the default return value policy (<a href="#id4"><span class="problematic" id="id5">:enum:`return_value_policy::automatic`</span></a>)
causes pybind11 to assume ownership of the static <code class="docutils literal notranslate"><span class="pre">_data</span></code> instance.</p>
<p>When Python’s garbage collector eventually deletes the Python
wrapper, pybind11 will also attempt to delete the C++ instance (via <code class="docutils literal notranslate"><span class="pre">operator</span>
<span class="pre">delete()</span></code>) due to the implied ownership. At this point, the entire application
will come crashing down, though errors could also be more subtle and involve
silent data corruption.</p>
<p>In the above example, the policy <a href="#id6"><span class="problematic" id="id7">:enum:`return_value_policy::reference`</span></a> should have
been specified so that the global data instance is only <em>referenced</em> without any
implied transfer of ownership, i.e.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_data&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">get_data</span><span class="p">,</span> <span class="n">return_value_policy</span><span class="o">::</span><span class="n">reference</span><span class="p">);</span>
</pre></div>
</div>
<p>On the other hand, this is not the right policy for many other situations,
where ignoring ownership could lead to resource leaks.
As a developer using pybind11, it’s important to be familiar with the different
return value policies, including which situation calls for which one of them.
The following table provides an overview of available policies:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return value policy</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a href="#id8"><span class="problematic" id="id9">:enum:`return_value_policy::take_ownership`</span></a></p></td>
<td><p>Reference an existing object (i.e. do not create a new copy) and take
ownership. Python will call the destructor and delete operator when the
object’s reference count reaches zero. Undefined behavior ensues when the
C++ side does the same, or when the data was not dynamically allocated.</p></td>
</tr>
<tr class="row-odd"><td><p><a href="#id10"><span class="problematic" id="id11">:enum:`return_value_policy::copy`</span></a></p></td>
<td><p>Create a new copy of the returned object, which will be owned by Python.
This policy is comparably safe because the lifetimes of the two instances
are decoupled.</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id12"><span class="problematic" id="id13">:enum:`return_value_policy::move`</span></a></p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">std::move</span></code> to move the return value contents into a new instance
that will be owned by Python. This policy is comparably safe because the
lifetimes of the two instances (move source and destination) are decoupled.</p></td>
</tr>
<tr class="row-odd"><td><p><a href="#id14"><span class="problematic" id="id15">:enum:`return_value_policy::reference`</span></a></p></td>
<td><p>Reference an existing object, but do not take ownership. The C++ side is
responsible for managing the object’s lifetime and deallocating it when
it is no longer used. Warning: undefined behavior will ensue when the C++
side deletes an object that is still referenced and used by Python.</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id16"><span class="problematic" id="id17">:enum:`return_value_policy::reference_internal`</span></a></p></td>
<td><p>Indicates that the lifetime of the return value is tied to the lifetime
of a parent object, namely the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code>, or <code class="docutils literal notranslate"><span class="pre">self</span></code> argument of
the called method or property. Internally, this policy works just like
<a href="#id18"><span class="problematic" id="id19">:enum:`return_value_policy::reference`</span></a> but additionally applies a
<code class="docutils literal notranslate"><span class="pre">keep_alive&lt;0,</span> <span class="pre">1&gt;</span></code> <em>call policy</em> (described in the next section) that
prevents the parent object from being garbage collected as long as the
return value is referenced by Python. This is the default policy for
property getters created via <code class="docutils literal notranslate"><span class="pre">def_property</span></code>, <code class="docutils literal notranslate"><span class="pre">def_readwrite</span></code>, etc.</p></td>
</tr>
<tr class="row-odd"><td><p><a href="#id20"><span class="problematic" id="id21">:enum:`return_value_policy::automatic`</span></a></p></td>
<td><p><strong>Default policy.</strong> This policy falls back to the policy
<a href="#id22"><span class="problematic" id="id23">:enum:`return_value_policy::take_ownership`</span></a> when the return value is a
pointer. Otherwise, it uses <a href="#id24"><span class="problematic" id="id25">:enum:`return_value_policy::move`</span></a> or
<a href="#id26"><span class="problematic" id="id27">:enum:`return_value_policy::copy`</span></a> for rvalue and lvalue references,
respectively. See above for a description of what all of these different
policies do.</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id28"><span class="problematic" id="id29">:enum:`return_value_policy::automatic_reference`</span></a></p></td>
<td><p>As above, but use policy <a href="#id30"><span class="problematic" id="id31">:enum:`return_value_policy::reference`</span></a> when the
return value is a pointer. This is the default conversion policy for
function arguments when calling Python functions manually from C++ code
(i.e. via handle::operator()). You probably won’t need to use this.</p></td>
</tr>
</tbody>
</table>
<p>Return value policies can also be applied to properties:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def_property</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">getData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">setData</span><span class="p">,</span>
                  <span class="n">py</span><span class="o">::</span><span class="n">return_value_policy</span><span class="o">::</span><span class="n">copy</span><span class="p">);</span>
</pre></div>
</div>
<p>Technically, the code above applies the policy to both the getter and the
setter function, however, the setter doesn’t really care about <em>return</em>
value policies which makes this a convenient terse syntax. Alternatively,
targeted arguments can be passed through the <code class="xref py py-class docutils literal notranslate"><span class="pre">cpp_function</span></code> constructor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def_property</span><span class="p">(</span><span class="s">&quot;data&quot;</span>
        <span class="n">py</span><span class="o">::</span><span class="n">cpp_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">getData</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">return_value_policy</span><span class="o">::</span><span class="n">copy</span><span class="p">),</span>
        <span class="n">py</span><span class="o">::</span><span class="n">cpp_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">setData</span><span class="p">)</span>
    <span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Code with invalid return value policies might access uninitialized memory or
free data structures multiple times, which can lead to hard-to-debug
non-determinism and segmentation faults, hence it is worth spending the
time to understand all the different options in the table above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>One important aspect of the above policies is that they only apply to
instances which pybind11 has <em>not</em> seen before, in which case the policy
clarifies essential questions about the return value’s lifetime and
ownership.  When pybind11 knows the instance already (as identified by its
type and address in memory), it will return the existing Python object
wrapper rather than creating a new copy.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>The next section on <a class="reference internal" href="#call-policies"><span class="std std-ref">Additional call policies</span></a> discusses <em>call policies</em> that can be
specified <em>in addition</em> to a return value policy from the list above. Call
policies indicate reference relationships that can involve both return values
and parameters of functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>As an alternative to elaborate call policies and lifetime management logic,
consider using smart pointers (see the section on <a class="reference internal" href="smart_ptrs.html#id1"><span class="std std-ref">Custom smart pointers</span></a> for
details). Smart pointers can tell whether an object is still referenced from
C++ or Python, which generally eliminates the kinds of inconsistencies that
can lead to crashes or undefined behavior. For functions returning smart
pointers, it is not necessary to specify a return value policy.</p>
</div>
</div>
<div class="section" id="additional-call-policies">
<span id="call-policies"></span><h2>Additional call policies<a class="headerlink" href="#additional-call-policies" title="永久链接至标题">¶</a></h2>
<p>In addition to the above return value policies, further <em>call policies</em> can be
specified to indicate dependencies between parameters or ensure a certain state
for the function call.</p>
<div class="section" id="keep-alive">
<h3>Keep alive<a class="headerlink" href="#keep-alive" title="永久链接至标题">¶</a></h3>
<p>In general, this policy is required when the C++ object is any kind of container
and another object is being added to the container. <code class="docutils literal notranslate"><span class="pre">keep_alive&lt;Nurse,</span> <span class="pre">Patient&gt;</span></code>
indicates that the argument with index <code class="docutils literal notranslate"><span class="pre">Patient</span></code> should be kept alive at least
until the argument with index <code class="docutils literal notranslate"><span class="pre">Nurse</span></code> is freed by the garbage collector. Argument
indices start at one, while zero refers to the return value. For methods, index
<code class="docutils literal notranslate"><span class="pre">1</span></code> refers to the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer, while regular arguments begin at
index <code class="docutils literal notranslate"><span class="pre">2</span></code>. Arbitrarily many call policies can be specified. When a <code class="docutils literal notranslate"><span class="pre">Nurse</span></code>
with value <code class="docutils literal notranslate"><span class="pre">None</span></code> is detected at runtime, the call policy does nothing.</p>
<p>When the nurse is not a pybind11-registered type, the implementation internally
relies on the ability to create a <em>weak reference</em> to the nurse object. When
the nurse object is not a pybind11-registered type and does not support weak
references, an exception will be thrown.</p>
<p>Consider the following example: here, the binding code for a list append
operation ties the lifetime of the newly added element to the underlying
container:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;List&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;append&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">List</span><span class="o">::</span><span class="n">append</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">keep_alive</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p>For consistency, the argument indexing is identical for constructors. Index
<code class="docutils literal notranslate"><span class="pre">1</span></code> still refers to the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer, i.e. the object which is
being constructed. Index <code class="docutils literal notranslate"><span class="pre">0</span></code> refers to the return type which is presumed to
be <code class="docutils literal notranslate"><span class="pre">void</span></code> when a constructor is viewed like a function. The following example
ties the lifetime of the constructor element to the constructed object:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Nurse</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Nurse&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">Patient</span> <span class="o">&amp;&gt;</span><span class="p">(),</span> <span class="n">py</span><span class="o">::</span><span class="n">keep_alive</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">keep_alive</span></code> is analogous to the <code class="docutils literal notranslate"><span class="pre">with_custodian_and_ward</span></code> (if Nurse,
Patient != 0) and <code class="docutils literal notranslate"><span class="pre">with_custodian_and_ward_postcall</span></code> (if Nurse/Patient ==
0) policies from Boost.Python.</p>
</div>
</div>
<div class="section" id="call-guard">
<h3>Call guard<a class="headerlink" href="#call-guard" title="永久链接至标题">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">call_guard&lt;T&gt;</span></code> policy allows any scope guard type <code class="docutils literal notranslate"><span class="pre">T</span></code> to be placed
around the function call. For example, this definition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">call_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p>is equivalent to the following pseudocode:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">args</span><span class="p">...)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">scope_guard</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">foo</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span> <span class="c1">// forwarded arguments</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The only requirement is that <code class="docutils literal notranslate"><span class="pre">T</span></code> is default-constructible, but otherwise any
scope guard will work. This is very useful in combination with <cite>gil_scoped_release</cite>.
See <a class="reference internal" href="misc.html#gil"><span class="std std-ref">Global Interpreter Lock (GIL)</span></a>.</p>
<p>Multiple guards can also be specified as <code class="docutils literal notranslate"><span class="pre">py::call_guard&lt;T1,</span> <span class="pre">T2,</span> <span class="pre">T3...&gt;</span></code>. The
constructor order is left to right and destruction happens in reverse.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_call_policies.cpp</span></code> contains a complete example
that demonstrates using <cite>keep_alive</cite> and <cite>call_guard</cite> in more detail.</p>
</div>
</div>
</div>
<div class="section" id="python-objects-as-arguments">
<span id="python-objects-as-args"></span><h2>Python objects as arguments<a class="headerlink" href="#python-objects-as-arguments" title="永久链接至标题">¶</a></h2>
<p>pybind11 exposes all major Python types using thin C++ wrapper classes. These
wrapper classes can also be used as parameters of functions in bindings, which
makes it possible to directly work with native Python types on the C++ side.
For instance, the following statement iterates over a Python <code class="docutils literal notranslate"><span class="pre">dict</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">print_dict</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">dict</span> <span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Easily interact with Python types */</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">dict</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">str</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">first</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="s">&quot;value=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">str</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">second</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It can be exported:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;print_dict&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">print_dict</span><span class="p">);</span>
</pre></div>
</div>
<p>And used in Python as usual:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_dict</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">})</span>
<span class="go">key=foo, value=123</span>
<span class="go">key=bar, value=hello</span>
</pre></div>
</div>
<p>For more information on using Python objects in C++, see <span class="xref std std-doc">/advanced/pycpp/index</span>.</p>
</div>
<div class="section" id="accepting-args-and-kwargs">
<h2>Accepting *args and **kwargs<a class="headerlink" href="#accepting-args-and-kwargs" title="永久链接至标题">¶</a></h2>
<p>Python provides a useful mechanism to define functions that accept arbitrary
numbers of arguments and keyword arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do something with args and kwargs</span>
</pre></div>
</div>
<p>Such functions can also be created using pybind11:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">generic</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">args</span> <span class="n">args</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">kwargs</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">/// .. do something with args</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1">/// .. do something with kwargs</span>
<span class="p">}</span>

<span class="c1">/// Binding code</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">generic</span><span class="p">);</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">py::args</span></code> derives from <code class="docutils literal notranslate"><span class="pre">py::tuple</span></code> and <code class="docutils literal notranslate"><span class="pre">py::kwargs</span></code> derives
from <code class="docutils literal notranslate"><span class="pre">py::dict</span></code>.</p>
<p>You may also use just one or the other, and may combine these with other
arguments as long as the <code class="docutils literal notranslate"><span class="pre">py::args</span></code> and <code class="docutils literal notranslate"><span class="pre">py::kwargs</span></code> arguments are the last
arguments accepted by the function.</p>
<p>Please refer to the other examples for details on how to iterate over these,
and on how to cast their entries into C++ objects. A demonstration is also
available in <code class="docutils literal notranslate"><span class="pre">tests/test_kwargs_and_defaults.cpp</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>When combining *args or **kwargs with <a class="reference internal" href="../basics.html#keyword-args"><span class="std std-ref">Keyword arguments</span></a> you should
<em>not</em> include <code class="docutils literal notranslate"><span class="pre">py::arg</span></code> tags for the <code class="docutils literal notranslate"><span class="pre">py::args</span></code> and <code class="docutils literal notranslate"><span class="pre">py::kwargs</span></code>
arguments.</p>
</div>
</div>
<div class="section" id="default-arguments-revisited">
<h2>Default arguments revisited<a class="headerlink" href="#default-arguments-revisited" title="永久链接至标题">¶</a></h2>
<p>The section on <a class="reference internal" href="../basics.html#default-args"><span class="std std-ref">Default arguments</span></a> previously discussed basic usage of default
arguments using pybind11. One noteworthy aspect of their implementation is that
default arguments are converted to Python objects right at declaration time.
Consider the following example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;myFunction&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;arg&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">SomeType</span><span class="p">(</span><span class="mi">123</span><span class="p">));</span>
</pre></div>
</div>
<p>In this case, pybind11 must already be set up to deal with values of the type
<code class="docutils literal notranslate"><span class="pre">SomeType</span></code> (via a prior instantiation of <code class="docutils literal notranslate"><span class="pre">py::class_&lt;SomeType&gt;</span></code>), or an
exception will be thrown.</p>
<p>Another aspect worth highlighting is that the “preview” of the default argument
in the function signature is generated using the object’s <code class="docutils literal notranslate"><span class="pre">__repr__</span></code> method.
If not available, the signature may not be very helpful, e.g.:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">FUNCTIONS</span>
<span class="gp">...</span>
<span class="go">|  myFunction(...)</span>
<span class="go">|      Signature : (MyClass, arg : SomeType = &lt;SomeType object at 0x101b7b080&gt;) -&gt; NoneType</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The first way of addressing this is by defining <code class="docutils literal notranslate"><span class="pre">SomeType.__repr__</span></code>.
Alternatively, it is possible to specify the human-readable preview of the
default argument manually using the <code class="docutils literal notranslate"><span class="pre">arg_v</span></code> notation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;myFunction&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">arg_v</span><span class="p">(</span><span class="s">&quot;arg&quot;</span><span class="p">,</span> <span class="n">SomeType</span><span class="p">(</span><span class="mi">123</span><span class="p">),</span> <span class="s">&quot;SomeType(123)&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Sometimes it may be necessary to pass a null pointer value as a default
argument. In this case, remember to cast it to the underlying type in question,
like so:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;myFunction&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;arg&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">SomeType</span> <span class="o">*</span><span class="p">)</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="non-converting-arguments">
<span id="nonconverting-arguments"></span><h2>Non-converting arguments<a class="headerlink" href="#non-converting-arguments" title="永久链接至标题">¶</a></h2>
<p>Certain argument types may support conversion from one type to another.  Some
examples of conversions are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="classes.html#implicit-conversions"><span class="std std-ref">Implicit conversions</span></a> declared using <code class="docutils literal notranslate"><span class="pre">py::implicitly_convertible&lt;A,B&gt;()</span></code></p></li>
<li><p>Calling a method accepting a double with an integer argument</p></li>
<li><p>Calling a <code class="docutils literal notranslate"><span class="pre">std::complex&lt;float&gt;</span></code> argument with a non-complex python type
(for example, with a float).  (Requires the optional <code class="docutils literal notranslate"><span class="pre">pybind11/complex.h</span></code>
header).</p></li>
<li><p>Calling a function taking an Eigen matrix reference with a numpy array of the
wrong type or of an incompatible data layout.  (Requires the optional
<code class="docutils literal notranslate"><span class="pre">pybind11/eigen.h</span></code> header).</p></li>
</ul>
<p>This behaviour is sometimes undesirable: the binding code may prefer to raise
an error rather than convert the argument.  This behaviour can be obtained
through <code class="docutils literal notranslate"><span class="pre">py::arg</span></code> by calling the <code class="docutils literal notranslate"><span class="pre">.noconvert()</span></code> method of the <code class="docutils literal notranslate"><span class="pre">py::arg</span></code>
object, such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;floats_only&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span> <span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">).</span><span class="n">noconvert</span><span class="p">());</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;floats_preferred&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span> <span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Attempting the call the second function (the one without <code class="docutils literal notranslate"><span class="pre">.noconvert()</span></code>) with
an integer will succeed, but attempting to call the <code class="docutils literal notranslate"><span class="pre">.noconvert()</span></code> version
will fail with a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">floats_preferred</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floats_only</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">floats_only(): incompatible function arguments. The following argument types are supported:</span>
<span class="go">    1. (f: float) -&gt; float</span>

<span class="go">Invoked with: 4</span>
</pre></div>
</div>
<p>You may, of course, combine this with the <a href="#id32"><span class="problematic" id="id33">:var:`_a`</span></a> shorthand notation (see
<a class="reference internal" href="../basics.html#keyword-args"><span class="std std-ref">Keyword arguments</span></a>) and/or <a class="reference internal" href="../basics.html#default-args"><span class="std std-ref">Default arguments</span></a>.  It is also permitted to omit
the argument name by using the <code class="docutils literal notranslate"><span class="pre">py::arg()</span></code> constructor without an argument
name, i.e. by specifying <code class="docutils literal notranslate"><span class="pre">py::arg().noconvert()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>When specifying <code class="docutils literal notranslate"><span class="pre">py::arg</span></code> options it is necessary to provide the same
number of options as the bound function has arguments.  Thus if you want to
enable no-convert behaviour for just one of several arguments, you will
need to specify a <code class="docutils literal notranslate"><span class="pre">py::arg()</span></code> annotation for each argument with the
no-convert argument modified to <code class="docutils literal notranslate"><span class="pre">py::arg().noconvert()</span></code>.</p>
</div>
</div>
<div class="section" id="allow-prohibiting-none-arguments">
<span id="none-arguments"></span><h2>Allow/Prohibiting None arguments<a class="headerlink" href="#allow-prohibiting-none-arguments" title="永久链接至标题">¶</a></h2>
<p>When a C++ type registered with <code class="xref py py-class docutils literal notranslate"><span class="pre">py::class_</span></code> is passed as an argument to
a function taking the instance as pointer or shared holder (e.g. <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>
or a custom, copyable holder as described in <a class="reference internal" href="smart_ptrs.html#id1"><span class="std std-ref">Custom smart pointers</span></a>), pybind
allows <code class="docutils literal notranslate"><span class="pre">None</span></code> to be passed from Python which results in calling the C++
function with <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> (or an empty holder) for the argument.</p>
<p>To explicitly enable or disable this behaviour, using the
<code class="docutils literal notranslate"><span class="pre">.none</span></code> method of the <code class="xref py py-class docutils literal notranslate"><span class="pre">py::arg</span></code> object:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Dog&quot;</span><span class="p">).</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Cat&quot;</span><span class="p">).</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;bark&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dog</span><span class="p">)</span> <span class="k">return</span> <span class="s">&quot;woof!&quot;</span><span class="p">;</span> <span class="cm">/* Called with a Dog instance */</span>
    <span class="k">else</span> <span class="k">return</span> <span class="s">&quot;(no dog)&quot;</span><span class="p">;</span> <span class="cm">/* Called with None, dog == nullptr */</span>
<span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;dog&quot;</span><span class="p">).</span><span class="n">none</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;meow&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">Cat</span> <span class="o">*</span><span class="n">cat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
    <span class="c1">// Can&#39;t be called with None argument</span>
    <span class="k">return</span> <span class="s">&quot;meow&quot;</span><span class="p">;</span>
<span class="p">},</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">).</span><span class="n">none</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>With the above, the Python call <code class="docutils literal notranslate"><span class="pre">bark(None)</span></code> will return the string <code class="docutils literal notranslate"><span class="pre">&quot;(no</span>
<span class="pre">dog)&quot;</span></code>, while attempting to call <code class="docutils literal notranslate"><span class="pre">meow(None)</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">animals</span> <span class="kn">import</span> <span class="n">Dog</span><span class="p">,</span> <span class="n">Cat</span><span class="p">,</span> <span class="n">bark</span><span class="p">,</span> <span class="n">meow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bark</span><span class="p">(</span><span class="n">Dog</span><span class="p">())</span>
<span class="go">&#39;woof!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meow</span><span class="p">(</span><span class="n">Cat</span><span class="p">())</span>
<span class="go">&#39;meow&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bark</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&#39;(no dog)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meow</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">meow(): incompatible function arguments. The following argument types are supported:</span>
<span class="go">    1. (cat: animals.Cat) -&gt; str</span>

<span class="go">Invoked with: None</span>
</pre></div>
</div>
<p>The default behaviour when the tag is unspecified is to allow <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Even when <code class="docutils literal notranslate"><span class="pre">.none(true)</span></code> is specified for an argument, <code class="docutils literal notranslate"><span class="pre">None</span></code> will be converted to a
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code> <em>only</em> for custom and <a class="reference internal" href="cast/stl.html#opaque"><span class="std std-ref">opaque</span></a> types. Pointers to built-in types
(<code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code>, …) and STL types (<code class="docutils literal notranslate"><span class="pre">std::vector&lt;T&gt;</span> <span class="pre">*</span></code>, …; if <code class="docutils literal notranslate"><span class="pre">pybind11/stl.h</span></code>
is included) are copied when converted to C++ (see <span class="xref std std-doc">/advanced/cast/overview</span>) and will
not allow <code class="docutils literal notranslate"><span class="pre">None</span></code> as argument.  To pass optional argument of these copied types consider
using <code class="docutils literal notranslate"><span class="pre">std::optional&lt;T&gt;</span></code></p>
</div>
</div>
<div class="section" id="overload-resolution-order">
<h2>Overload resolution order<a class="headerlink" href="#overload-resolution-order" title="永久链接至标题">¶</a></h2>
<p>When a function or method with multiple overloads is called from Python,
pybind11 determines which overload to call in two passes.  The first pass
attempts to call each overload without allowing argument conversion (as if
every argument had been specified as <code class="docutils literal notranslate"><span class="pre">py::arg().noconvert()</span></code> as described
above).</p>
<p>If no overload succeeds in the no-conversion first pass, a second pass is
attempted in which argument conversion is allowed (except where prohibited via
an explicit <code class="docutils literal notranslate"><span class="pre">py::arg().noconvert()</span></code> attribute in the function definition).</p>
<p>If the second pass also fails a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised.</p>
<p>Within each pass, overloads are tried in the order they were registered with
pybind11.</p>
<p>What this means in practice is that pybind11 will prefer any overload that does
not require conversion of arguments to an overload that does, but otherwise prefers
earlier-defined overloads to later-defined ones.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>pybind11 does <em>not</em> further prioritize based on the number/pattern of
overloaded arguments.  That is, pybind11 does not prioritize a function
requiring one conversion over one requiring three, but only prioritizes
overloads requiring no conversion at all to overloads that require
conversion of at least one argument.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Horizon Robotics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>